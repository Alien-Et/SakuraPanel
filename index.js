import { createHTMLResponse, createRedirectResponse, createJSONResponse } from './utils/response.js';
import { checkLock, generateLoginRegisterPage, encryptPassword } from './utils/auth.js';
import { loadNodesAndConfig, getConfig, getOrInitializeUUID } from './utils/nodes.js';
import { generateSubscriptionPage, generateKvNotBoundPage, generateCatConfig, generateUniversalConfig } from './utils/generate.js';
import { handleWebSocketUpgrade, handleSocks5Connection } from './utils/websocket.js';
import { mockKvInstance } from './utils/mock-kv.js';

// Âü∫Á°ÄÈÖçÁΩÆ
const CONFIG_PATH = "config";
let PREFERRED_NODES = [];
let PROXY_ADDRESS = 'ts.hpc.tw';
let SOCKS5_ACCOUNT = '';
let NODE_NAME = 'üå∏Ê®±Ëä±';
let FAKE_DOMAIN = 'lkssite.vip';
let MAX_FAILURES = 5;
let LOCK_TIME = 5 * 60 * 1000;
let LIGHT_BG_IMAGE = 'https://i.meee.com.tw/el91luR.png';
let DARK_BG_IMAGE = 'https://i.meee.com.tw/QPWx8nX.png';

export default {
  async fetch(request, env) {
    try {
      // ‰ªéÁéØÂ¢ÉÂèòÈáèËØªÂèñÈÖçÁΩÆ
      PROXY_ADDRESS = env.PROXYIP || PROXY_ADDRESS;
      SOCKS5_ACCOUNT = env.SOCKS5 || SOCKS5_ACCOUNT;
      const isDevelopmentMode = env.DEVELOPMENT_MODE === 'true';
      
      // Ê£ÄÊü•ÊòØÂê¶ÊúâKVÊï∞ÊçÆÂ∫ìÔºåÂ¶ÇÊûúÊ≤°Êúâ‰∏îÂ§Ñ‰∫éÂºÄÂèëÊ®°ÂºèÔºåÂàô‰ΩøÁî®Ê®°ÊãüKV
      if (!env.KVÊï∞ÊçÆÂ∫ì) {
        if (isDevelopmentMode) {
          // ÂºÄÂèëÊ®°Âºè‰∏ã‰ΩøÁî®Ê®°ÊãüKVÊï∞ÊçÆÂ∫ì
          env.KVÊï∞ÊçÆÂ∫ì = mockKvInstance;
          console.log('ÂºÄÂèëÊ®°ÂºèÔºö‰ΩøÁî®Ê®°ÊãüKVÊï∞ÊçÆÂ∫ì');
        } else {
          return createHTMLResponse(generateKvNotBoundPage(LIGHT_BG_IMAGE, DARK_BG_IMAGE));
        }
      }

      const upgradeHeader = request.headers.get('Upgrade');
      const url = new URL(request.url);
      const hostName = request.headers.get('Host');
      const UA = request.headers.get('User-Agent') || 'unknown';
      const IP = request.headers.get('CF-Connecting-IP') || 'unknown';
      const deviceId = `${UA}_${IP}`;
      let formData;

      // WebSocket Â§ÑÁêÜ
      if (upgradeHeader && upgradeHeader === 'websocket') {
        await loadNodesAndConfig(env, hostName, PREFERRED_NODES, NODE_NAME);
        return await handleWebSocketUpgrade(request, env, hostName, PREFERRED_NODES);
      }

      // Ë°®ÂçïÊï∞ÊçÆÂ§ÑÁêÜ
      if (url.pathname === '/login/submit' || url.pathname === '/register/submit') {
        const contentType = request.headers.get('Content-Type') || '';
        if (!contentType.includes('application/x-www-form-urlencoded') && !contentType.includes('multipart/form-data')) {
          console.log(`Êó†ÊïàËØ∑Ê±Ç: UA=${UA}, IP=${IP}, Path=${url.pathname}, Headers=${JSON.stringify([...request.headers])}`);
          return createHTMLResponse(generateLoginRegisterPage(url.pathname === '/login/submit' ? 'ÁôªÂΩï' : 'Ê≥®ÂÜå', {
            ÈîôËØØ‰ø°ÊÅØ: 'ËØ∑ÈÄöËøáÊ≠£Â∏∏Ë°®ÂçïÊèê‰∫§'
          }, LIGHT_BG_IMAGE, DARK_BG_IMAGE), 400);
        }

        try {
          formData = await request.formData();
        } catch (error) {
          return createHTMLResponse(generateLoginRegisterPage(url.pathname === '/login/submit' ? 'ÁôªÂΩï' : 'Ê≥®ÂÜå', {
            ÈîôËØØ‰ø°ÊÅØ: 'Êèê‰∫§Êï∞ÊçÆÊ†ºÂºèÈîôËØØÔºåËØ∑ÈáçËØï'
          }, LIGHT_BG_IMAGE, DARK_BG_IMAGE), 400);
        }
      }

      // Ê≥®ÂÜåÂ§ÑÁêÜ
      if (url.pathname === '/register/submit') {
        const username = formData.get('username');
        const password = formData.get('password');
        const confirmPassword = formData.get('confirm');

        if (!username || !password || password !== confirmPassword) {
          return createHTMLResponse(generateLoginRegisterPage('Ê≥®ÂÜå', {
            ÈîôËØØ‰ø°ÊÅØ: password !== confirmPassword ? '‰∏§Ê¨°ÂØÜÁ†Å‰∏ç‰∏ÄËá¥' : 'ËØ∑Â°´ÂÜôÂÆåÊï¥‰ø°ÊÅØ'
          }, LIGHT_BG_IMAGE, DARK_BG_IMAGE), 400);
        }

        const existingUser = await env.KVÊï∞ÊçÆÂ∫ì.get('stored_credentials');
        if (existingUser) {
          return createRedirectResponse('/login');
        }

        const encryptedPassword = await encryptPassword(password);
        await env.KVÊï∞ÊçÆÂ∫ì.put('stored_credentials', JSON.stringify({
          username, password: encryptedPassword
        }));

        const newToken = Math.random().toString(36).substring(2);
        await env.KVÊï∞ÊçÆÂ∫ì.put('current_token', newToken, { expirationTtl: 300 });
        return createRedirectResponse(`/${CONFIG_PATH}`, {
          'Set-Cookie': `token=${newToken}; Path=/; HttpOnly; SameSite=Strict`
        });
      }

      // ÁôªÂΩïÂ§ÑÁêÜ
      if (url.pathname === '/login/submit') {
        const lockStatus = await checkLock(env, deviceId, LOCK_TIME);
        if (lockStatus.Ë¢´ÈîÅÂÆö) {
          return createHTMLResponse(generateLoginRegisterPage('ÁôªÂΩï', {
            ÈîÅÂÆöÁä∂ÊÄÅ: true,
            Ââ©‰ΩôÊó∂Èó¥: lockStatus.Ââ©‰ΩôÊó∂Èó¥
          }, LIGHT_BG_IMAGE, DARK_BG_IMAGE), 403);
        }

        const storedCredentials = await env.KVÊï∞ÊçÆÂ∫ì.get('stored_credentials');
        if (!storedCredentials) {
          return createRedirectResponse('/register');
        }

        const inputUsername = formData.get('username');
        const inputPassword = formData.get('password');

        const credentialsObj = JSON.parse(storedCredentials || '{}');
        const passwordMatch = (await encryptPassword(inputPassword)) === credentialsObj.password;
        if (inputUsername === credentialsObj.username && passwordMatch) {
          const newToken = Math.random().toString(36).substring(2);
          await env.KVÊï∞ÊçÆÂ∫ì.put('current_token', newToken, { expirationTtl: 300 });
          await env.KVÊï∞ÊçÆÂ∫ì.put(`fail_${deviceId}`, '0');
          return createRedirectResponse(`/${CONFIG_PATH}`, {
            'Set-Cookie': `token=${newToken}; Path=/; HttpOnly; SameSite=Strict`
          });
        }

        let failureCount = Number(await env.KVÊï∞ÊçÆÂ∫ì.get(`fail_${deviceId}`) || 0) + 1;
        await env.KVÊï∞ÊçÆÂ∫ì.put(`fail_${deviceId}`, String(failureCount));

        if (failureCount >= MAX_FAILURES) {
          await env.KVÊï∞ÊçÆÂ∫ì.put(`lock_${deviceId}`, String(Date.now() + LOCK_TIME), { expirationTtl: 300 });
          const newLockStatus = await checkLock(env, deviceId, LOCK_TIME);
          return createHTMLResponse(generateLoginRegisterPage('ÁôªÂΩï', {
            ÈîÅÂÆöÁä∂ÊÄÅ: true,
            Ââ©‰ΩôÊó∂Èó¥: newLockStatus.Ââ©‰ΩôÊó∂Èó¥
          }, LIGHT_BG_IMAGE, DARK_BG_IMAGE), 403);
        }

        return createHTMLResponse(generateLoginRegisterPage('ÁôªÂΩï', {
          ËæìÈîôÂØÜÁ†Å: true,
          Ââ©‰ΩôÊ¨°Êï∞: MAX_FAILURES - failureCount
        }, LIGHT_BG_IMAGE, DARK_BG_IMAGE), 401);
      }

      // Ê£ÄÊü•ÊòØÂê¶Â∑≤Ê≥®ÂÜå
      const isRegistered = await env.KVÊï∞ÊçÆÂ∫ì.get('stored_credentials');
      if (!isRegistered && url.pathname !== '/register') {
        return createHTMLResponse(generateLoginRegisterPage('Ê≥®ÂÜå', {}, LIGHT_BG_IMAGE, DARK_BG_IMAGE));
      }

      // Ë∑ØÁî±Â§ÑÁêÜ
      switch (url.pathname) {
        case '/login':
          const storedCredentials = await env.KVÊï∞ÊçÆÂ∫ì.get('stored_credentials');
          if (!storedCredentials) {
            return createRedirectResponse('/register');
          }

          const lockStatus = await checkLock(env, deviceId, LOCK_TIME);
          if (lockStatus.Ë¢´ÈîÅÂÆö) {
            return createHTMLResponse(generateLoginRegisterPage('ÁôªÂΩï', { ÈîÅÂÆöÁä∂ÊÄÅ: true, Ââ©‰ΩôÊó∂Èó¥: lockStatus.Ââ©‰ΩôÊó∂Èó¥ }, LIGHT_BG_IMAGE, DARK_BG_IMAGE));
          }
          if (request.headers.get('Cookie')?.split('=')[1] === await env.KVÊï∞ÊçÆÂ∫ì.get('current_token')) {
            return createRedirectResponse(`/${CONFIG_PATH}`);
          }
          const failureCount = Number(await env.KVÊï∞ÊçÆÂ∫ì.get(`fail_${deviceId}`) || 0);
          return createHTMLResponse(generateLoginRegisterPage('ÁôªÂΩï', { ËæìÈîôÂØÜÁ†Å: failureCount > 0, Ââ©‰ΩôÊ¨°Êï∞: MAX_FAILURES - failureCount }, LIGHT_BG_IMAGE, DARK_BG_IMAGE));

        case '/reset-login-failures':
          await env.KVÊï∞ÊçÆÂ∫ì.put(`fail_${deviceId}`, '0');
          await env.KVÊï∞ÊçÆÂ∫ì.delete(`lock_${deviceId}`);
          return new Response(null, { status: 200 });

        case '/check-lock':
          const lockCheck = await checkLock(env, deviceId, LOCK_TIME);
          return createJSONResponse({
            locked: lockCheck.Ë¢´ÈîÅÂÆö,
            remainingTime: lockCheck.Ââ©‰ΩôÊó∂Èó¥
          });

        case `/${CONFIG_PATH}`:
          const token = request.headers.get('Cookie')?.split('=')[1];
          const validToken = await env.KVÊï∞ÊçÆÂ∫ì.get('current_token');
          if (!token || token !== validToken) return createRedirectResponse('/login');
          const uuid = await getOrInitializeUUID(env);
          return createHTMLResponse(generateSubscriptionPage(CONFIG_PATH, hostName, uuid, LIGHT_BG_IMAGE, DARK_BG_IMAGE));

        case `/${CONFIG_PATH}/logout`:
          await env.KVÊï∞ÊçÆÂ∫ì.delete('current_token');
          return createRedirectResponse('/login', { 'Set-Cookie': 'token=; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT; HttpOnly; SameSite=Strict' });

        case `/${CONFIG_PATH}/` + atob('Y2xhc2g='):
          await loadNodesAndConfig(env, hostName, PREFERRED_NODES, NODE_NAME);
          const catConfig = await getConfig(env, atob('Y2xhc2g='), hostName, generateCatConfig);
          return new Response(catConfig, { status: 200, headers: { "Content-Type": "text/plain;charset=utf-8" } });

        case `/${CONFIG_PATH}/` + atob('djJyYXluZw=='):
          await loadNodesAndConfig(env, hostName, PREFERRED_NODES, NODE_NAME);
          const universalConfig = await getConfig(env, atob('djJyYXk='), hostName, generateUniversalConfig);
          return new Response(universalConfig, { status: 200, headers: { "Content-Type": "text/plain;charset=utf-8" } });

        case `/${CONFIG_PATH}/upload`:
          const uploadToken = request.headers.get('Cookie')?.split('=')[1];
          const validUploadToken = await env.KVÊï∞ÊçÆÂ∫ì.get('current_token');
          if (!uploadToken || uploadToken !== validUploadToken) {
            return createJSONResponse({ error: 'Êú™ÁôªÂΩïÊàñTokenÊó†ÊïàÔºåËØ∑ÈáçÊñ∞ÁôªÂΩï' }, 401);
          }
          formData = await request.formData();
          const ipFiles = formData.getAll('ipFiles');
          if (!ipFiles || ipFiles.length === 0) {
            return createJSONResponse({ error: 'Êú™ÈÄâÊã©‰ªª‰ΩïÊñá‰ª∂' }, 400);
          }
          let allIpList = [];
          try {
            for (const ipFile of ipFiles) {
              if (!ipFile || !ipFile.text) throw new Error(`Êñá‰ª∂ ${ipFile.name} Êó†Êïà`);
              const ipText = await ipFile.text();
              const ipList = ipText.split('\n').map(line => line.trim()).filter(Boolean);
              if (ipList.length === 0) console.warn(`Êñá‰ª∂ ${ipFile.name} ÂÜÖÂÆπ‰∏∫Á©∫`);
              allIpList = allIpList.concat(ipList);
            }
            if (allIpList.length === 0) {
              return createJSONResponse({ error: 'ÊâÄÊúâ‰∏ä‰º†Êñá‰ª∂ÂÜÖÂÆπ‰∏∫Á©∫' }, 400);
            }
            const uniqueIpList = [...new Set(allIpList)];

            const currentManualNodes = await env.KVÊï∞ÊçÆÂ∫ì.get('manual_preferred_ips');
            const currentNodeList = currentManualNodes ? JSON.parse(currentManualNodes) : [];
            const isDuplicateUpload = JSON.stringify(currentNodeList.sort()) === JSON.stringify(uniqueIpList.sort());
            if (isDuplicateUpload) {
              return createJSONResponse({ message: '‰∏ä‰º†ÂÜÖÂÆπ‰∏éÁé∞ÊúâËäÇÁÇπÁõ∏ÂêåÔºåÊó†ÈúÄÊõ¥Êñ∞' }, 200);
            }

            await env.KVÊï∞ÊçÆÂ∫ì.put('manual_preferred_ips', JSON.stringify(uniqueIpList));
            const newVersion = String(Date.now());
            await env.KVÊï∞ÊçÆÂ∫ì.put('ip_preferred_ips_version', newVersion);
            await env.KVÊï∞ÊçÆÂ∫ì.put('config_' + atob('Y2xhc2g='), await generateCatConfig(env, hostName, PREFERRED_NODES, NODE_NAME));
            await env.KVÊï∞ÊçÆÂ∫ì.put('config_' + atob('Y2xhc2g=') + '_version', newVersion);
            await env.KVÊï∞ÊçÆÂ∫ì.put('config_' + atob('djJyYXk='), await generateUniversalConfig(env, hostName, PREFERRED_NODES, NODE_NAME));
            await env.KVÊï∞ÊçÆÂ∫ì.put('config_' + atob('djJyYXk=') + '_version', newVersion);
            return createJSONResponse({ message: '‰∏ä‰º†ÊàêÂäüÔºåÂç≥Â∞ÜË∑≥ËΩ¨' }, 200, { 'Location': `/${CONFIG_PATH}` });
          } catch (error) {
            console.error(`‰∏ä‰º†Â§ÑÁêÜÂ§±Ë¥•: ${error.message}`);
            return createJSONResponse({ error: `‰∏ä‰º†Â§ÑÁêÜÂ§±Ë¥•: ${error.message}` }, 500);
          }

        case `/${CONFIG_PATH}/change-uuid`:
          const changeToken = request.headers.get('Cookie')?.split('=')[1];
          const validChangeToken = await env.KVÊï∞ÊçÆÂ∫ì.get('current_token');
          if (!changeToken || changeToken !== validChangeToken) {
            return createJSONResponse({ error: 'Êú™ÁôªÂΩïÊàñTokenÊó†Êïà' }, 401);
          }
          const newUUID = generateUUID();
          await env.KVÊï∞ÊçÆÂ∫ì.put('current_uuid', newUUID);
          await env.KVÊï∞ÊçÆÂ∫ì.put('config_' + atob('Y2xhc2g='), await generateCatConfig(env, hostName, PREFERRED_NODES, NODE_NAME));
          await env.KVÊï∞ÊçÆÂ∫ì.put('config_' + atob('djJyYXk='), await generateUniversalConfig(env, hostName, PREFERRED_NODES, NODE_NAME));
          const newVersion = String(Date.now());
          await env.KVÊï∞ÊçÆÂ∫ì.put('config_' + atob('Y2xhc2g=') + '_version', newVersion);
          await env.KVÊï∞ÊçÆÂ∫ì.put('config_' + atob('djJyYXk=') + '_version', newVersion);
          return createJSONResponse({ uuid: newUUID }, 200);

        case `/${CONFIG_PATH}/add-node-path`:
          const addToken = request.headers.get('Cookie')?.split('=')[1];
          const validAddToken = await env.KVÊï∞ÊçÆÂ∫ì.get('current_token');
          if (!addToken || addToken !== validAddToken) {
            return createJSONResponse({ error: 'Êú™ÁôªÂΩïÊàñTokenÊó†Êïà' }, 401);
          }
          const addData = await request.json();
          const newPath = addData.path;
          if (!newPath || !newPath.match(/^https?:\/\//)) {
            return createJSONResponse({ error: 'Êó†ÊïàÁöÑURLÊ†ºÂºè' }, 400);
          }
          let currentPaths = await env.KVÊï∞ÊçÆÂ∫ì.get('node_file_paths');
          currentPaths = currentPaths ? JSON.parse(currentPaths) : [];
          if (currentPaths.includes(newPath)) {
            return createJSONResponse({ error: 'ËØ•Ë∑ØÂæÑÂ∑≤Â≠òÂú®' }, 400);
          }
          currentPaths.push(newPath);
          await env.KVÊï∞ÊçÆÂ∫ì.put('node_file_paths', JSON.stringify(currentPaths));
          await loadNodesAndConfig(env, hostName, PREFERRED_NODES, NODE_NAME);
          return createJSONResponse({ success: true }, 200);

        case `/${CONFIG_PATH}/remove-node-path`:
          const removeToken = request.headers.get('Cookie')?.split('=')[1];
          const validRemoveToken = await env.KVÊï∞ÊçÆÂ∫ì.get('current_token');
          if (!removeToken || removeToken !== validRemoveToken) {
            return createJSONResponse({ error: 'Êú™ÁôªÂΩïÊàñTokenÊó†Êïà' }, 401);
          }
          const removeData = await request.json();
          const index = removeData.index;
          let paths = await env.KVÊï∞ÊçÆÂ∫ì.get('node_file_paths');
          paths = paths ? JSON.parse(paths) : [];
          if (index < 0 || index >= paths.length) {
            return createJSONResponse({ error: 'Êó†ÊïàÁöÑÁ¥¢Âºï' }, 400);
          }
          paths.splice(index, 1);
          await env.KVÊï∞ÊçÆÂ∫ì.put('node_file_paths', JSON.stringify(paths));
          await loadNodesAndConfig(env, hostName, PREFERRED_NODES, NODE_NAME);
          return createJSONResponse({ success: true }, 200);

        case `/${CONFIG_PATH}/get-node-paths`:
          const getToken = request.headers.get('Cookie')?.split('=')[1];
          const validGetToken = await env.KVÊï∞ÊçÆÂ∫ì.get('current_token');
          if (!getToken || getToken !== validGetToken) {
            return createJSONResponse({ error: 'Êú™ÁôªÂΩïÊàñTokenÊó†Êïà' }, 401);
          }
          let nodePaths = await env.KVÊï∞ÊçÆÂ∫ì.get('node_file_paths');
          nodePaths = nodePaths ? JSON.parse(nodePaths) : ['https://v2.i-sweet.us.kg/ips.txt', 'https://v2.i-sweet.us.kg/url.txt'];
          return createJSONResponse({ paths: nodePaths }, 200);

        case '/set-proxy-state':
          formData = await request.formData();
          const proxyEnabled = formData.get('proxyEnabled');
          const proxyType = formData.get('proxyType');
          const forceProxy = formData.get('forceProxy');
          await env.KVÊï∞ÊçÆÂ∫ì.put('proxyEnabled', proxyEnabled);
          await env.KVÊï∞ÊçÆÂ∫ì.put('proxyType', proxyType);
          await env.KVÊï∞ÊçÆÂ∫ì.put('forceProxy', forceProxy);
          return new Response(null, { status: 200 });

        case '/get-proxy-status':
          const currentProxyEnabled = await env.KVÊï∞ÊçÆÂ∫ì.get('proxyEnabled') === 'true';
          const currentProxyType = await env.KVÊï∞ÊçÆÂ∫ì.get('proxyType') || 'reverse';
          const currentForceProxy = await env.KVÊï∞ÊçÆÂ∫ì.get('forceProxy') === 'true';
          const proxyAddress = env.PROXYIP || 'ts.hpc.tw';
          const socks5Account = env.SOCKS5 || '';
          let status = 'Áõ¥Ëøû';
          if (currentProxyEnabled) {
            if (currentForceProxy) {
              status = currentProxyType === 'reverse' && proxyAddress ? 'Âº∫Âà∂Âèç‰ª£' : 'Âº∫Âà∂SOCKS5';
            } else if (currentProxyType === 'reverse' && proxyAddress) {
              status = 'Âä®ÊÄÅÂèç‰ª£';
            } else if (currentProxyType === 'socks5' && socks5Account) {
              status = 'Âä®ÊÄÅSOCKS5';
            }
          }
          return createJSONResponse({ status });

        default:
          url.hostname = FAKE_DOMAIN;
          url.protocol = 'https:';
          return fetch(new Request(url, request));
      }
    } catch (error) {
      console.error(`ÂÖ®Â±ÄÈîôËØØ: ${error.message}`);
      return createJSONResponse({ error: `ÊúçÂä°Âô®ÂÜÖÈÉ®ÈîôËØØ: ${error.message}` }, 500);
    }
  }
};

// ËæÖÂä©ÂáΩÊï∞
function generateUUID() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}